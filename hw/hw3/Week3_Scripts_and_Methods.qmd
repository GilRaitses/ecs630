---
title: "ECS 630 - Week 3 Scripts and Methods"
author: "Gil Raitses"
date: "September 22, 2025"
format:
  pdf:
    geometry: margin=1in
    fontsize: 11pt
    include-in-header:
      - text: |
          \usepackage{amsmath}
          \usepackage{amsfonts}
          \usepackage{amssymb}
---

This document provides the submission information, modeling methods, and scripts used to generate the Week 3 results for the painting, drying, and finishing system. The implementation follows a discrete-event simulation design with a single replication over a 24-hour horizon. The arrival process is exponential with mean five minutes, the painting operation time follows a triangular distribution with minimum one minute, mode four and a half minutes, and maximum seven minutes, drying is a fixed fifteen-minute delay with a capacity limit of ten concurrent parts, and the finishing operation time follows a uniform distribution between half a minute and nine minutes. The queues are first-come, first-served and the servers are non-preemptive.

The simulation is implemented in Python as a next-event time advance system with an event calendar maintained by a heap queue. Each part is assigned a unique identifier and its timestamps of arrival, start and completion of painting, start and completion of drying, and start and completion of finishing are recorded. The state of the system includes the painting queue, the drying in-progress counter with a waiting queue if needed, and the finishing queue, in addition to server busy indicators. Time-average statistics are accumulated by integrating the relevant processes over time between event epochs.

The equations for the reported metrics are as follows. The time-average number in the system is computed as the integral over time of the number of parts present divided by the horizon length. The time-average numbers in the painting and finishing queues are computed analogously for the respective queue length processes. The utilization of each server equals the integral over time of its busy indicator divided by the horizon length. The average waiting time in each queue is computed as the mean, over parts that began service during the observation window, of the time between queue entry and service start. The average total time in system is computed as the mean, over parts that completed finishing within the observation window, of the elapsed time from arrival to departure.

The code used for the simulation is reproduced below for transparency and reproducibility.

```python
# File: hw/hw3/simulate_week3.py
# Entry point: python3 simulate_week3.py
# Outputs: results_week3.json, results_week3.csv, timeline_week3.csv

# (See repository file for full context; excerpt shown here.)
import json, csv, heapq, random, os
from collections import deque
from dataclasses import dataclass, field
from typing import Optional, List, Tuple, Dict

random.seed(6303)

@dataclass(order=True)
class Event:
    time: float
    priority: int
    event_type: str = field(compare=False)
    entity_id: Optional[int] = field(compare=False, default=None)

# ... class PaintingSystemSimulation with event handlers arrival, paint_done,
# drying_done, finish_done; distributions: exponential(5), triangular(1,4.5,7),
# uniform(0.5,9); time-average area accumulators; JSON/CSV writers ...
```

The outputs generated by the script include a JSON file with the scalar metrics and CSV files that contain the same metrics and an event timeline suitable for diagnostics. The metrics are injected into the Week 3 assignment document and displayed in the figure for clear presentation. The notation in the equations corresponds to standard queueing and simulation symbols where \(N(t)\) is the number in system, \(Q_p(t)\) and \(Q_f(t)\) are the painting and finishing queue lengths, and \(B_p(t)\) and \(B_f(t)\) are the corresponding busy indicators. The integration horizon is \(T=1440\) minutes.
